@page "/gameRoom/{RoomName}"
@using Models
@using Services

<h3>Players:</h3>
@foreach (var player in room.Players)
{
    <div>
        <span>@player</span>
        @if (player == room.GetCurrentPlayer())
        {
            <span>X</span>
        }
    </div>
}

<div class="main-row">
    <div class="row">
        @foreach (var piece in room.Game.PiecesOnTable)
        {
            <PieceComponent OnDrop="@DropPieceOnTable" Model="@piece"/>
        }
    </div>
</div>
<br />

<div class="draw-piece">
    <div>Draw here:</div>
    <PieceComponent OnDrop="@EmptyDropPiece" Model="@drawPiece"/>
</div>

<div class="fixed-bottom">
    <div class="board">
        <div class="row">
            <div class="ml-auto mr-auto row">
                @foreach (var player in room.Game.Players)
                {
                    <div>
                        @foreach (var set in player.Value.Sets)
                        {
                            <div class="row">
                                @foreach (var piece in set)
                                {
                                    <PieceComponent OnDrop="@EmptyDropPiece" Model="@piece"/>
                                }
                            </div>
                        }
                        <div>@player.Key</div>
                    </div>
                }
            </div>
        </div>
        <div class="row">
            <div class="ml-auto mr-auto row">
                @foreach (var piece in piecesSetOnTable)
                {
                    <PieceComponent OnDrop="@DropPieceOnPiecesSetOnTable" Model="@piece"/>
                }
            </div>
        </div>

        <div class="row">
            <div style="color:red">@errorMessage</div>
        </div>

        @for (int x = 0; x < piecesOnBoard.GetLength(0); ++x)
        {
            <div class="row">
                @for (int y = 0; y < piecesOnBoard.GetLength(1); ++y)
                {
                    <PieceComponent OnDrop="@DropPieceOnBoard" Model="@piecesOnBoard[x, y]"/>
                }
            </div>
        }
    </div>
</div>


@code {
    [Parameter]
    private string RoomName { get; set; }

    [CascadingParameter]
    Task<AuthenticationState>
    authenticationStateTask
    { get; set; }

    //to do: remove this:
    PieceModel drawPiece = new PieceModel(PieceModel.Types.Empty,
    PieceModel.Locations.PiecesToDraw);

    PieceModel[,] piecesOnBoard = new PieceModel[3, 14];
    List<PieceModel>
        piecesToDraw = new List<PieceModel>
            ();
    List<PieceModel>
        piecesSetOnTable = new List<PieceModel>
            {
                    new PieceModel(PieceModel.Types.Empty,
                    PieceModel.Locations.piecesSetOnTable),
                    new PieceModel(PieceModel.Types.Empty,
                    PieceModel.Locations.piecesSetOnTable),
                    new PieceModel(PieceModel.Types.Empty,
                    PieceModel.Locations.piecesSetOnTable),
                        };

    string errorMessage = "";

    RoomState room;
    string userName;

    protected override async Task OnInitAsync()
    {
        room = AllRoomsState.Rooms[RoomName];

        room.OnDropPieceOnTable += StateChanged;
        room.OnDropSetOnTable += StateChanged;

        var authState = await authenticationStateTask;
        var user = authState.User;
        if (user.Identity.IsAuthenticated)
        {
            userName = user.Identity.Name;
        }

        piecesOnBoard = PutPiecesOnBoard(room.GetPlayerBoardPieces(userName));
    }


    void StateChanged()
    {
        Invoke(() => StateHasChanged());
    }

    void DropPieceOnBoard(PieceModel source, PieceModel target)
    {
        if (target.Type != PieceModel.Types.Empty &&
        source.Location == PieceModel.Locations.PiecesToDraw)
        {
            errorMessage = "You cannot put in the same place as another piece";
            StateHasChanged();
            return;
        }

        if (source.Location == PieceModel.Locations.PiecesToDraw)
        {
            var response = room.DrawPiece(userName);
            if (!response.Success)
            {
                errorMessage = response.Message;
                StateHasChanged();
                return;
            }

            target.Number = response.Piece.Number;
            target.Color = response.Piece.Color;
            target.Type = response.Piece.Type;
            StateHasChanged();
            return;
        }

        SwitchPieces(source, target);
        StateHasChanged();
    }

    void EmptyDropPiece(PieceModel source, PieceModel target) { }

    void DropPieceOnPiecesSetOnTable(PieceModel source, PieceModel target)
    {
        if (source.Location != PieceModel.Locations.Board)
        {
            return;
        }

        SwitchPieces(source, target);

        if (piecesSetOnTable.All(p => p.Type != PieceModel.Types.Empty))
        {
            var response = room.AddSet(piecesSetOnTable, userName);
            if (!response.Success)
            {
                errorMessage = response.Message;
            }
            else
            {
                piecesSetOnTable = new List<PieceModel>
        {
                    new PieceModel(PieceModel.Types.Empty,
                    PieceModel.Locations.piecesSetOnTable),
                    new PieceModel(PieceModel.Types.Empty,
                    PieceModel.Locations.piecesSetOnTable),
                    new PieceModel(PieceModel.Types.Empty,
                    PieceModel.Locations.piecesSetOnTable),
                };
            }
        }

        StateHasChanged();
    }

    void DropPieceOnTable(PieceModel source, PieceModel target)
    {
        if (source.Location != PieceModel.Locations.Board)
        {
            errorMessage = "You must put a piece from the board to the table";
            StateHasChanged();
            return;
        }

        if (source.Type == PieceModel.Types.Empty)
        {
            return;
        }

        var response = room.DropPieceOnTable(source, userName);
        if (!response.Success)
        {
            errorMessage = response.Message;
            StateHasChanged();
            return;
        }

        source.Type = PieceModel.Types.Empty;
        source.Number = 0;
        StateHasChanged();
    }

    private PieceModel[,] PutPiecesOnBoard(List<PieceModel>
        pieces)
    {
        var piecesOnBoard = new PieceModel[3, 14];
        for (int i = 0; i < pieces.Count; i++)
        {
            var piece = pieces[i];
            piecesOnBoard[0, i] = new PieceModel(piece.Number, piece.Color,
            PieceModel.Locations.Board);
        }

        for (int i = 0; i <= 13; i++)
        {
            piecesOnBoard[1, i] = new PieceModel(PieceModel.Types.Empty,
            PieceModel.Locations.Board);
        }

        for (int i = 0; i <= 13; i++)
        {
            piecesOnBoard[2, i] = new PieceModel(PieceModel.Types.Empty,
            PieceModel.Locations.Board);
        }

        return piecesOnBoard;
    }

    private void SwitchPieces(PieceModel source, PieceModel target)
    {
        var tmpColor = source.Color;
        var tmpNumber = source.Number;
        var tmpType = source.Type;
        source.Color = target.Color;
        source.Number = target.Number;
        source.Type = target.Type;
        target.Color = tmpColor;
        target.Number = tmpNumber;
        target.Type = tmpType;
    }
}
